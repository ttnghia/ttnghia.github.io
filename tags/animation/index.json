[{"content":"An implementation of loose octree with application in collision detection for particle simulation.\nDescription This is a simple, single-threaded implementation of a loose octree which is commonplace in computer graphics. It is used for various purposes, for example, for collision detection in particle simulation, as in this program.\nDownload Magnum example page with more description\nCode (github) from Magnum repository\nWindows binary\nUsage  Mouse drag rotates the camera Shift + mouse drag pans the camera Mouse wheel zooms in/out R resets the camera to its original transformation B shows/hides tree node bounding boxes Space pauses/resumes particle simulation  Additionally, various options can be set via command line:\n-s, --spheres N — number of spheres to simulate (default: 50)\r-r, --sphere-radius R — sphere radius (default: 0.1)\r-v, --sphere-velocity V — sphere velocity (default: 1)\rFor example:\nOctree.exe -s 20 -r 0.1 -v 1.0\rGallery ","description":"","id":0,"section":"posts","tags":["code","graphics","octree","c++","magnum"],"title":"Octree","uri":"https://ttnghia.github.io/posts/octree/"},{"content":"I am a Ph.D. candidate in Scientific Computing track at School of Computing, University of Utah, working with Cem Yuksel since 2014 on various problems in computer graphics. My interest not only includes graphics but cloud computing, machine learning, web application and general software engineering.\nBefore coming to the University of Utah, I received my BSc and MSc at Department of Mechanics and Mathematics, Tula State University, Russia and worked as R\u0026amp;D staff at the Institute for Computational Science and Technology, Ho Chi Minh city, Vietnam.\nThe best way to contact me is through my email: nghiatruong.vn [@gmail.com]\n","description":"About me","id":1,"section":"","tags":null,"title":"About","uri":"https://ttnghia.github.io/about/"},{"content":"Food made by my family at home :)\n","description":"Food made by my family at home","id":2,"section":"gallery","tags":null,"title":"Food","uri":"https://ttnghia.github.io/gallery/food/"},{"content":"An implementation of Ken Shoemake\u0026rsquo;s arcball camera with smooth navigation feature.\nDescription This is an implementation of Ken Shoemake\u0026rsquo;s arcball camera with smooth navigation feature. Using arcball, the camera control is more accurate and consistent.\nDownload Magnum example page with more description\nCode (github) from Magnum repository\nWindows binary\nUsage  Mouse drag rotates the camera Shift + mouse drag pans the camera Mouse wheel zooms in/out R resets the camera to its original transformation L toggles lagging (smooth camera navigation)  Gallery ","description":"","id":3,"section":"posts","tags":["code","graphics","c++","magnum"],"title":"ArcBall Camera","uri":"https://ttnghia.github.io/posts/arcball-camera/"},{"content":"An implementation of a simple ray tracer adapted from Peter Shirley\u0026rsquo;s book Ray Tracing in One Weekend.\nDescription This is an implementation of a simple ray tracer adapted from Peter Shirley\u0026rsquo;s book Ray Tracing in One Weekend. The current implementation runs on single thread and performs iterative rendering to refine the result. Typically, a high quality image can be achieved after around 100 iterations. In addition, a new scene can be easily generated to overwrite the current scene by a keyboard shortcut.\nDownload Magnum example page with more description\nCode (github) from Magnum repository\nWindows binary\nUsage  Mouse drag rotates the camera Shift + mouse drag pans the camera Mouse wheel zooms in/out R resets the camera to its original transformation D toggles depth-of-field rendering M toggles marking the next render block by a different color N generates a new random scene Space pauses/resumes rendering  Gallery ","description":"","id":4,"section":"posts","tags":["code","graphics","ray tracing","rendering","c++","magnum"],"title":"Ray Tracing In One Weekend","uri":"https://ttnghia.github.io/posts/ray-tracing-in-one-weekend/"},{"content":"A 2D fluid simulation using the hybrid grid/particle approach with APIC (Affine Particle-in-Cell) transfer.\nDescription A 2D fluid simulation using the hybrid grid/particle approach with APIC (Affine Particle-in-Cell) transfer.\nDownload Magnum example page with more description\nCode (github) from Magnum repository\nWindows binary\nUsage  Mouse drag rotates the camera E emits more particles H shows/hides the overlaid menu R resets the simulation Space pauses/resumes the simulation  Gallery \r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r","description":"","id":5,"section":"posts","tags":["code","graphics","fluid","simulation","particle","c++","magnum"],"title":"Fluid Simulation 2D","uri":"https://ttnghia.github.io/posts/fluid-simulation-2d/"},{"content":"Description A basic implementation of SPH (Smoothed-Particle Hydrodynamics) solver with a dynamic boundary. In order to run in real time, accuracy has been heavily sacrificed for performance.\nI also had another SPH simulation code which only deals with static boundary here.\nDownload Magnum example page with more description\nCode (github) from Magnum repository\nWindows binary\nUsage  Mouse drag rotates the camera Shift + mouse drag pans the camera Mouse wheel zooms in/out H shows/hides the overlaid menu R resets the simulation Space pauses/resumes the simulation  Gallery ","description":"","id":6,"section":"posts","tags":["code","graphics","fluid","simulation","particle","c++","magnum"],"title":"SPH Fluid Simulation (v2)","uri":"https://ttnghia.github.io/posts/sph-fluid-simulation-v2/"},{"content":"Selected photo shot by me around the world, whenever I have a chance.\n","description":"Photo shot by me","id":7,"section":"gallery","tags":null,"title":"Photo","uri":"https://ttnghia.github.io/gallery/photo/"},{"content":"Description This page contains various simulations as the results of parameter-turning experiments during developing my simulation framework with Material Point Method. As it is an on-going project, source code is not released in this work.\nReferences My simulations are produced by implementing the following papers:\n Drucker-prager elastoplasticity for sand animation Anisotropic elastoplasticity for cloth, knit and hair frictional contact  Animated GIFs Please be patient! Animation (images) below need some time to load\u0026hellip;\nSand Animation 2D Strands Collision 2D (Anisotropic MPM) Big Strand Bundle (Anisotropic MPM) Strand Bundles Collision (Anisotropic MPM) ","description":"","id":8,"section":"posts","tags":["graphics","animation","simulation","MPM","sand","hair","strand"],"title":"Material Point Method for Elastoplastic Simulations","uri":"https://ttnghia.github.io/posts/mpm-simulations/"},{"content":"A simple tool for visualizing particle-based simulation data.\nDescription This is a simple tool for visualizing particle-based simulation data quickly. The input data need to be written as a file sequence (such as animation.0001.obj, animation.0002.obj etc).\nCurrently, there are 3 file formats supported: Partio (*.bgeo), Wavefront (*.obj), and binary (*.bin or *.pos). More details, program usage, program binary (win64) and examples data (three animations in this page) are provided in my github repository in the following section.\nDownload Code (github) with windows prebuild\nGallery (Animated GIFs) ","description":"","id":9,"section":"posts","tags":["code","graphics","fluid","simulation","rendering","visualization","particle","c++"],"title":"Particle Visualizer","uri":"https://ttnghia.github.io/posts/particle-visualizer/"},{"content":"A tool for generating evenly distributed particles from a given geometry.\nDescription Particle-based simulation is prevalent in computer graphics. In order to run the simulations, we firstly need to have particles. Therefore, generating particles in a desired distribution is very important, if not indispensable. If the simulation resolution is not high enough, uneven distributed particles could probably lead to wrong solutions, or at least ugly looking results.\nI have struggled a lot in trying to generate evenly distributed particles for my simulation projects and came up with several solutions. One of them is Lloyd relaxation, but it requires two levels particle sampling - one normal scale and one much smaller scale, leading to huge amount of memory usage and yields very slow performance. Another solution is using SPH-based blue noise relaxation, which has a very good performance and produces good results and became my top choice. I implement that algorithm in my program ParticleSampler, which allows to generate particles from a given geometry, run relaxation over the generated particles, and save the results to disk for further processing somewhere else. More details about the program and its usage is discussed more in detail in my github project below.\nDownload Code (github) with examples scene and docs\nGallery \r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\rVideo \r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r","description":"","id":10,"section":"posts","tags":["code","graphics","particle","simulation","c++"],"title":"Particle Sampling with SPH-based Relaxation","uri":"https://ttnghia.github.io/posts/particle-sampling-with-sph-relaxation/"},{"content":"Nghia Truong and Cem Yuksel\rACM SIGGRAPH Symposium on Interactive 3D Graphics and Games 2018\r\rAbstract We introduce a simple screen-space filtering technique for real-time rendering of particle-based fluid simulations. Starting with a depth-map generated directly from the particle data, our new filter formulation smooths the depth-map by considering the depth values in a narrow range. The depth values outside of this range are carefully handled to achieve the desired surface shape near discontinuities. The simplicity of our formulation leads to a computationally efficient filter. We present examples with complex particle-based fluid simulations and provide comparisons, clearly showing that our filter provides improved surface quality in terms of surface smoothness and preserving boundaries near discontinuities, as compared to prior filtering methods.\nDownload Paper (preprint, 23MB pdf) Code (github)\nBibTeX @article{Truong2018,\rauthor = {Truong, Nghia and Yuksel, Cem},\rtitle = {A Narrow-Range Filter for Screen-Space Fluid Rendering},\ryear = {2018},\rissue_date = {July 2018},\rpublisher = {The Association for Computers in Mathematics and Science Teaching},\rvolume = {1},\rnumber = {1},\rjournal = {Proc. ACM Comput. Graph. Interact. Tech.},\rmonth = jul,\rarticleno = {17},\rnumpages = {15}\r}\rVideo \r\rGallery ","description":"","id":11,"section":"posts","tags":["publication","graphics","fluid","simulation","rendering","code","c++"],"title":"A Narrow-Range Filter for Screen-Space Fluid Rendering","uri":"https://ttnghia.github.io/posts/narrow-range-filter/"},{"content":"Kui Wu, Nghia Truong, Cem Yuksel, Rama Hoetzlein\rEurographics 2018\r\rAbstract We introduce efficient, large scale fluid simulation on GPU hardware using the fluid-implicit particle (FLIP) method over a sparse hierarchy of grids represented in NVIDIA GVDB Voxels. Our approach handles tens of millions of particles within a virtually unbounded simulation domain. We describe novel techniques for parallel sparse grid hierarchy construction and fast incremental updates on the GPU for moving particles. In addition, our FLIP technique introduces sparse, work efficient parallel data gathering from particle to voxel, and a matrix-free GPU-based conjugate gradient solver optimized for sparse grids. Our results show that our method can achieve up to an order of magnitude faster simulations on the GPU as compared to FLIP simulations running on the CPU.\nDownload Paper (preprint, 13MB pdf)\nBibTeX @article{Wu2018,\rauthor = {Wu, Kui and Truong, Nghia and Yuksel, Cem and Hoetzlein, Rama},\rtitle = {Fast Fluid Simulations with Sparse Volumes on the GPU},\rjournal = {Computer Graphics Forum},\rvolume = {37},\rnumber = {2},\rpages = {157-167},\ryear = {2018},\rdoi = {10.1111/cgf.13350}\r}\rVideo \r\rGallery ","description":"","id":12,"section":"posts","tags":["publication","graphics","fluid","simulation"],"title":"Fast Fluid Simulations with Sparse Volumes on the GPU","uri":"https://ttnghia.github.io/posts/fast-fluid-simulation/"},{"content":"Description  Fluid simulation using Smoothed Particle Hydrodynamics (SPH) solver The program is implemented in Qt 5.9 framework. Multi-threading by Intel TBB libary. Show real-time memory usage. Skybox textures in folder Textures/Sky are automatically loaded at start up. Press Spacebar key to pause/resume the simulation. Press \u0026lsquo;R\u0026rsquo; key to reset camera view. A Prebuild has been provided to run immediately. As my implementation depends on a lot of external libaries, the source code can only be compiled by me.  Download Code (github) with windows prebuild\nVideo \r\rGallery ","description":"","id":13,"section":"posts","tags":["code","graphics","fluid","simulation","particle","sph","c++"],"title":"SPH Fluid Simulation (v1)","uri":"https://ttnghia.github.io/posts/sph-fluid-simulation-v1/"},{"content":"Description  The program is implemented in Qt 5.9 framework. Multi-threading by Intel TBB and fftw3_threads libraries. Skybox textures in folder Textures/Sky are automatically loaded at start up. Press Spacebar key to pause/resume the simulation. Simulation parameters can be changed and take effects in real time. A binary (in Pre-Build folder) has been provided. As my implementation depends on a lot of external libaries, the source code can only be compiled by me.  References:  Jerry Tessendorf, 1999. Simulating Ocean Water Some code in my program is adapted from this repository: https://github.com/ZijinZheng/OceanSurface  Download Code (github) with windows prebuild\nVideo \r\rGallery ","description":"","id":14,"section":"posts","tags":["code","graphics","fluid","simulation","rendering","c++"],"title":"FFT-based Ocean Surface Simulation","uri":"https://ttnghia.github.io/posts/fft-based-ocean-simulation/"}]